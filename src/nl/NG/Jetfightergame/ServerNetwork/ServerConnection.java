package nl.NG.Jetfightergame.ServerNetwork;

import nl.NG.Jetfightergame.AbstractEntities.GameEntity;
import nl.NG.Jetfightergame.AbstractEntities.MovingEntity;
import nl.NG.Jetfightergame.Engine.GameLoop.GameServer;
import nl.NG.Jetfightergame.Tools.Toolbox;

import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * can be viewed as a client's personal connection inside the server
 * @author Geert van Ieperen created on 5-5-2018.
 */
public class ServerConnection implements BlockingListener {
    private final InputStream clientIn;
    private final BufferedOutputStream clientOut;
    private final String clientName;
    public final boolean hasAdminCapabilities;

    private final GameServer server;
    private Lock sendOutput = new ReentrantLock();

    private final RemoteControlReceiver controls;

    public ServerConnection(Socket connection, boolean isAdmin, GameServer server) throws IOException {
        this.clientIn = connection.getInputStream();
        this.clientOut = new BufferedOutputStream(connection.getOutputStream());
        this.hasAdminCapabilities = isAdmin;
        this.server = server;
        this.controls = new RemoteControlReceiver();
        this.clientName = connection.toString();
    }

    /**
     * sends an update to the client of the given entity's position, rotation and velocity
     * @param thing the object to be updated
     * @param currentTime the time of when this entity is on the said position
     */
    public void sendEntityUpdate(MovingEntity thing, float currentTime) {
        sendOutput.lock();
        try {
            clientOut.write(MessageType.ENTITY_UPDATE.ordinal());
            JetFighterProtocol.entityUpdateSend(clientOut, thing, currentTime);
            clientOut.flush();

        } catch (IOException ex) {
            Toolbox.printError(ex);

        } finally {
            sendOutput.unlock();
        }
    }
    /**
     * sends the event of a newly spawned object
     * @param entity the entity to be sent
     * @param id its unique id, generated by the server
     */
    public void sendEntitySpawn(MovingEntity.Spawn entity, int id) {
        sendOutput.lock();
        try {
            clientOut.write(MessageType.ENTITY_SPAWN.ordinal());
            JetFighterProtocol.newEntitySend(clientOut, entity, id);
            clientOut.flush();

        } catch (IOException ex) {
            Toolbox.printError(ex);

        } finally {
            sendOutput.unlock();
        }
    }

    @Override
    public boolean handleMessage() throws IOException {
        MessageType type = MessageType.get(clientIn.read());

        if (type.isOf(MessageType.adminOnly) && !hasAdminCapabilities) {
            Toolbox.printError(this + " sent an " + type + " command, while it has no access to it");
            return true;

        } else if (type == MessageType.CONNECTION_CLOSE) {
            return false;
        }

        if (type.isOf(MessageType.controls)) {
            JetFighterProtocol.controlRead(clientIn, controls, type);

        } else if (type == MessageType.START_GAME) {
            server.unPause();

        } else if (type == MessageType.PAUSE_GAME) {
            server.pause();

        } else if (type == MessageType.SHUTDOWN_GAME){
            server.shutDown();

        } else if (type == MessageType.ENTITY_SPAWN) {
            // actually works for Jets
            MovingEntity.Spawn spawn = JetFighterProtocol.spawnRequestRead(clientIn);
            server.addSpawn(spawn);

        } else {
            long bits = clientIn.skip(type.nOfArgs());
            Toolbox.printError("Message caused an error: " + type, "skipping " + bits + " bits");
        }

        return true;
    }

    @Override
    public String toString() {
        return clientName;
    }

    /**
     * reads a new player from the client
     * @see ClientConnection#getPlayer()
     */
    public MovingEntity getPlayer(GameEntity.State position) throws IOException {
        // notify client
        clientOut.write(MessageType.CONFIRM_CONNECTION.ordinal());
        clientOut.flush();
        // listen to which plane is desired
        EntityClass type = JetFighterProtocol.playerSpawnAccept(clientIn);
        // create new plane
        MovingEntity.Spawn spawn = new MovingEntity.Spawn(type, position);
        // it sure may be a jet but nobody cares
        MovingEntity player = spawn.construct(server, controls);
        // notify client about his new acquisition
        JetFighterProtocol.newEntitySend(clientOut, spawn, player.idNumber());
        clientOut.flush();

        return player;
    }

}
