package nl.NG.Jetfightergame.ServerNetwork;

import nl.NG.Jetfightergame.AbstractEntities.GameEntity;
import nl.NG.Jetfightergame.AbstractEntities.MovingEntity;
import nl.NG.Jetfightergame.Engine.GameLoop.SpawnEntityManager;
import nl.NG.Jetfightergame.Engine.GameState.EntityManager;
import nl.NG.Jetfightergame.Engine.GameTimer;
import nl.NG.Jetfightergame.Tools.Toolbox;

import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * can be viewed as a client's personal connection inside the server
 * @author Geert van Ieperen created on 5-5-2018.
 */
public class ServerConnection implements BlockingListener {
    private final InputStream clientIn;
    private final BufferedOutputStream clientOut;
    private final String clientName;
    private final boolean hasAdminCapabilities;

    private final EntityManager game;
    private final SpawnEntityManager entityDisposal;
    private Lock sendOutput = new ReentrantLock();

    private final RemoteControlReceiver controls;

    public ServerConnection(Socket connection, boolean isAdmin, EntityManager game, SpawnEntityManager entityDisposal) throws IOException {
        this.clientIn = connection.getInputStream();
        this.clientOut = new BufferedOutputStream(connection.getOutputStream());
        this.hasAdminCapabilities = isAdmin;
        this.entityDisposal = entityDisposal;
        this.controls = new RemoteControlReceiver();
        this.clientName = connection.toString();
        this.game = game;
    }

    /**
     * sends an update to the client of the given entity's position, rotation and velocity
     * @param thing the object to be updated
     * @param currentTime the time of when this entity is on the said position
     */
    public void sendEntityUpdate(MovingEntity thing, float currentTime) {
        sendOutput.lock();
        try {
            clientOut.write(MessageType.ENTITY_UPDATE.ordinal());
            JetFighterProtocol.entityUpdateSend(clientOut, thing, currentTime);
            clientOut.flush();

        } catch (IOException ex) {
            Toolbox.printError(ex);

        } finally {
            sendOutput.unlock();
        }
    }
    /**
     * sends the event of a newly spawned object
     * @param entity the entity to be sent
     * @param id its unique id, generated by the server
     */
    public void sendEntitySpawn(MovingEntity.SpawnEntity entity, int id) {
        sendOutput.lock();
        try {
            clientOut.write(MessageType.ENTITY_SPAWN.ordinal());
            JetFighterProtocol.newEntitySend(clientOut, entity, id);
            clientOut.flush();

        } catch (IOException ex) {
            Toolbox.printError(ex);

        } finally {
            sendOutput.unlock();
        }
    }

    @Override
    public boolean handleMessage() throws IOException {
        MessageType type = MessageType.get(clientIn.read());
        Toolbox.print(type);

        if (type.isOf(MessageType.adminOnly) && !hasAdminCapabilities) {
            Toolbox.printError(this + " sent an " + type + " command, while it has no access to it");
            return true;
        }

        if (type.isOf(MessageType.controls)) {
            JetFighterProtocol.controlRead(clientIn, controls, type);

        } else if (type == MessageType.ENTITY_UPDATE) {
            JetFighterProtocol.entityUpdateRead(clientIn, game.getEntities());

        } else if (type == MessageType.ENTITY_SPAWN) {
            // actually works for Jets
            MovingEntity.SpawnEntity spawn = JetFighterProtocol.spawnRequestRead(clientIn);
            entityDisposal.addEntity(spawn, controls);

        } else {
            long bits = clientIn.skip(type.nOfArgs());
            Toolbox.printError("Message caused an error: " + type, "skipping " + bits + " bits");
        }

        return type != MessageType.CONNECTION_CLOSE;
    }

    @Override
    public String toString() {
        return clientName;
    }

    /**
     * reads a new player from the client
     * @see ClientConnection#getPlayer(GameTimer)
     */
    public MovingEntity getPlayer(GameEntity.State position, GameTimer time) throws IOException {
        // notify client
        clientOut.write(MessageType.CONFIRM_CONNECTION.ordinal());
        clientOut.flush();
        // listen to which plane is desired
        EntityClass type = EntityClass.get(clientIn.read());
        // create new plane
        MovingEntity.SpawnEntity spawn = new MovingEntity.SpawnEntity(type, position);
        MovingEntity player = spawn.construct(game, controls, time);
        // notify client about his new acquisition
        JetFighterProtocol.newEntitySend(clientOut, spawn, player.idNumber());
        clientOut.flush();

        return player;
    }
}
